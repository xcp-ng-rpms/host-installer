diff --git c/answerfile.py w/answerfile.py
index 490b49e..c8c26dd 100644
--- c/answerfile.py
+++ w/answerfile.py
@@ -92,6 +92,8 @@ class Answerfile:
             else:
                 raise AnswerfileException("Unknown mode, %s" % install_type)

+            results['repo-gpgcheck'] = getBoolAttribute(self.top_node, ['repo-gpgcheck'], default=True)
+            results['gpgcheck'] = getBoolAttribute(self.top_node, ['gpgcheck'], default=True)
             results.update(self.parseCommon())
         elif self.operation == 'restore':
             results = self.parseRestore()
@@ -133,6 +135,7 @@ class Answerfile:
         results['preserve-settings'] = False
         results['backup-existing-installation'] = False

+        results.update(self.parseRaid())
         results.update(self.parseDisks())
         results.update(self.parseInterface())
         results.update(self.parseRootPassword())
@@ -266,7 +269,21 @@ class Answerfile:
             if rtype == 'url':
                 address = util.URL(address)

-            results['sources'].append({'media': rtype, 'address': address})
+            # workaround getBoolAttribute() not allowing "None" as
+            # default, by using a getStrAttribute() call first to
+            # handle the default situation where the attribute is not
+            # specified
+            repo_gpgcheck = (None if getStrAttribute(i, ['repo-gpgcheck'], default=None) is None
+                             else getBoolAttribute(i, ['repo-gpgcheck']))
+            gpgcheck = (None if getStrAttribute(i, ['gpgcheck'], default=None) is None
+                        else getBoolAttribute(i, ['gpgcheck']))
+
+            results['sources'].append({
+                'media': rtype, 'address': address,
+                'repo_gpgcheck': repo_gpgcheck,
+                'gpgcheck': gpgcheck,
+            })
+            logger.log("parsed source %s" % results['sources'][-1])

         return results

@@ -293,6 +310,16 @@ class Answerfile:
             results['extra-repos'].append((rtype, address))
         return results

+    def parseRaid(self):
+        results = {}
+        for raid_node in getElementsByTagName(self.top_node, ['raid']):
+            disk_device = normalize_disk(getStrAttribute(raid_node, ['device'], mandatory=True))
+            disks = [normalize_disk(getText(node)) for node in getElementsByTagName(raid_node, ['disk'])]
+            if 'raid' not in results:
+                results['raid'] = {}
+            results['raid'][disk_device] = disks
+        return results
+
     def parseDisks(self):
         results = {}

diff --git c/backend.py w/backend.py
index 1788db7..3c49932 100644
--- c/backend.py
+++ w/backend.py
@@ -32,6 +32,7 @@ from xcp.version import Version
 import version
 from version import *
 from constants import *
+from diskutil import getRemovableDeviceList

 MY_PRODUCT_BRAND = PRODUCT_BRAND or PLATFORM_NAME

@@ -103,6 +104,7 @@ def getPrepSequence(ans, interactive):
         Task(util.getUUID, As(ans), ['installation-uuid']),
         Task(util.getUUID, As(ans), ['control-domain-uuid']),
         Task(util.randomLabelStr, As(ans), ['disk-label-suffix']),
+        Task(diskutil.create_raid, A(ans, 'raid'), []),
         Task(inspectTargetDisk, A(ans, 'primary-disk', 'installation-to-overwrite', 'preserve-first-partition','sr-on-primary'), ['target-boot-mode', 'boot-partnum', 'primary-partnum', 'backup-partnum', 'logs-partnum', 'swap-partnum', 'storage-partnum']),
         ]

@@ -160,7 +162,7 @@ def getMainRepoSequence(ans, repos):
 def getRepoSequence(ans, repos):
     seq = []
     for repo in repos:
-        seq.append(Task(repo.installPackages, A(ans, 'mounts'), [],
+        seq.append(Task(repo.installPackages, A(ans, 'mounts', 'kernel-alt'), [],
                      progress_scale=100,
                      pass_progress_callback=True,
                      progress_text="Installing %s..." % repo.name()))
@@ -170,6 +172,7 @@ def getRepoSequence(ans, repos):

 def getFinalisationSequence(ans):
     seq = [
+        Task(importYumAndRpmGpgKeys, A(ans, 'mounts'), []),
         Task(writeResolvConf, A(ans, 'mounts', 'manual-hostname', 'manual-nameservers'), []),
         Task(writeMachineID, A(ans, 'mounts'), []),
         Task(writeKeyboardConfiguration, A(ans, 'mounts', 'keymap'), []),
@@ -191,6 +194,7 @@ def getFinalisationSequence(ans):
                                   'boot-partnum', 'primary-partnum', 'target-boot-mode', 'branding',
                                   'disk-label-suffix', 'bootloader-location', 'write-boot-entry', 'install-type',
                                   'serial-console', 'boot-serial', 'host-config', 'fcoe-interfaces'), []),
+        Task(postInstallAltKernel, A(ans, 'mounts', 'kernel-alt'), []),
         Task(touchSshAuthorizedKeys, A(ans, 'mounts'), []),
         Task(setRootPassword, A(ans, 'mounts', 'root-password'), [], args_sensitive=True),
         Task(setTimeZone, A(ans, 'mounts', 'timezone'), []),
@@ -318,6 +322,10 @@ def performInstallation(answers, ui_package, interactive):
                                                          default_host_config['dom0-mem'])
                 default_host_config['dom0-vcpus'] = xcp.dom0.default_vcpus(hardware.getHostTotalCPUs(),
                                                                            answers['host-config']['dom0-mem'])
+
+            # Set scheduler granularity if necessary.
+            if 'sched-gran' in answers['host-config']:
+                default_host_config['sched-gran'] = answers['host-config']['sched-gran']
         except Exception as e:
             logger.logException(e)
             raise RuntimeError("Failed to get existing installation settings")
@@ -373,7 +381,7 @@ def performInstallation(answers, ui_package, interactive):
     main_repositories = []
     update_repositories = []

-    def add_repos(main_repositories, update_repositories, repos):
+    def add_repos(main_repositories, update_repositories, repos, repo_gpgcheck, gpgcheck):
         """Add repositories to the appropriate list, ensuring no duplicates,
         that the main repository is at the beginning, and that the order of the
         rest is maintained."""
@@ -390,20 +398,28 @@ def performInstallation(answers, ui_package, interactive):
                 else:
                     repo_list.append(repo)

+                if repo_list is main_repositories: # i.e., if repo is a "main repository"
+                    repo.setRepoGpgCheck(repo_gpgcheck)
+                    repo.setGpgCheck(gpgcheck)
+
+    default_repo_gpgcheck = answers.get('repo-gpgcheck', True)
+    default_gpgcheck = answers.get('gpgcheck', True)
     # A list of sources coming from the answerfile
     if 'sources' in answers_pristine:
         for i in answers_pristine['sources']:
             repos = repository.repositoriesFromDefinition(i['media'], i['address'])
-            add_repos(main_repositories, update_repositories, repos)
+            repo_gpgcheck = default_repo_gpgcheck if i['repo_gpgcheck'] is None else i['repo_gpgcheck']
+            gpgcheck = default_gpgcheck if i['gpgcheck'] is None else i['gpgcheck']
+            add_repos(main_repositories, update_repositories, repos, repo_gpgcheck, gpgcheck)

     # A single source coming from an interactive install
     if 'source-media' in answers_pristine and 'source-address' in answers_pristine:
         repos = repository.repositoriesFromDefinition(answers_pristine['source-media'], answers_pristine['source-address'])
-        add_repos(main_repositories, update_repositories, repos)
+        add_repos(main_repositories, update_repositories, repos, default_repo_gpgcheck, default_gpgcheck)

     for media, address in answers_pristine['extra-repos']:
         repos = repository.repositoriesFromDefinition(media, address)
-        add_repos(main_repositories, update_repositories, repos)
+        add_repos(main_repositories, update_repositories, repos, default_repo_gpgcheck, default_gpgcheck)

     if not main_repositories or main_repositories[0].identifier() != MAIN_REPOSITORY_NAME:
         raise RuntimeError("No main repository found")
@@ -418,6 +434,16 @@ def performInstallation(answers, ui_package, interactive):
         if r.accessor().canEject():
             r.accessor().eject()

+    # XCP-ng: so, very unfortunately we don't remember with precision why this was added and
+    # no commit message or comment can help us here.
+    # It may be related to the fact that the "all_repositories" above doesn't contain
+    # the installation CD-ROM or USB stick in the case of a netinstall.
+    # Question: why it is needed at all since there's no repository on the netinstall
+    # installation media?
+    if answers.get('netinstall'):
+        for device in getRemovableDeviceList():
+            util.runCmd2(['eject', device])
+
     if interactive:
         # Add supp packs in a loop
         while True:
@@ -1005,6 +1031,8 @@ def prepFallback(mounts, primary_disk, primary_partnum):
 def buildBootLoaderMenu(mounts, xen_version, xen_kernel_version, boot_config, serial, boot_serial, host_config, primary_disk, disk_label_suffix, fcoe_interfaces):
     short_version = kernelShortVersion(xen_kernel_version)
     common_xen_params = "dom0_mem=%dM,max:%dM" % ((host_config['dom0-mem'],) * 2)
+    if "sched-gran" in host_config:
+        common_xen_params += " %s" % host_config["sched-gran"]
     common_xen_unsafe_params = "watchdog ucode=scan dom0_max_vcpus=1-%d" % host_config['dom0-vcpus']
     safe_xen_params = ("nosmp noreboot noirqbalance no-mce no-bootscrub "
                        "no-numa no-hap no-mmcfg max_cstate=0 "
@@ -1119,7 +1147,11 @@ def installBootLoader(mounts, disk, boot_partnum, primary_partnum, target_boot_m
                 setEfiBootEntry(mounts, disk, boot_partnum, install_type, branding)
         else:
             if location == constants.BOOT_LOCATION_MBR:
-                installGrub2(mounts, disk, False)
+                if diskutil.is_raid(disk):
+                    for member in diskutil.getDeviceSlaves(disk):
+                        installGrub2(mounts, member, False)
+                else:
+                    installGrub2(mounts, disk, False)
             else:
                 installGrub2(mounts, root_partition, True)

@@ -1642,6 +1674,57 @@ def touchSshAuthorizedKeys(mounts):
     fh = open("%s/root/.ssh/authorized_keys" % mounts['root'], 'a')
     fh.close()

+def importYumAndRpmGpgKeys(mounts):
+    # Python script that uses yum functions to import the GPG key for our repositories
+    import_yum_keys = """#!/bin/env python
+from __future__ import print_function
+from yum import YumBase
+
+def retTrue(*args, **kwargs):
+    return True
+
+base = YumBase()
+for repo in base.repos.repos.itervalues():
+    if repo.id.startswith('xcp-ng'):
+        print("*** Importing GPG key for repository %s - %s" % (repo.id, repo.name))
+        base.getKeyForRepo(repo, callback=retTrue)
+"""
+    internal_tmp_filepath = '/tmp/import_yum_keys.py'
+    external_tmp_filepath = mounts['root'] + internal_tmp_filepath
+    with open(external_tmp_filepath, 'w') as f:
+        f.write(import_yum_keys)
+    # bind mount /dev, necessary for NSS initialization without which RPM won't work
+    util.bindMount('/dev', "%s/dev" % mounts['root'])
+    try:
+        util.runCmd2(['chroot', mounts['root'], 'python', internal_tmp_filepath])
+        util.runCmd2(['chroot', mounts['root'], 'rpm', '--import', '/etc/pki/rpm-gpg/RPM-GPG-KEY-xcpng'])
+    finally:
+        util.umount("%s/dev" % mounts['root'])
+        os.unlink(external_tmp_filepath)
+
+def postInstallAltKernel(mounts, kernel_alt):
+    """ Install our alternate kernel. Must be called after the bootloader installation. """
+    if not kernel_alt:
+        logger.log('kernel-alt not installed')
+        return
+
+    util.bindMount("/proc", "%s/proc" % mounts['root'])
+    util.bindMount("/sys", "%s/sys" % mounts['root'])
+    util.bindMount("/dev", "%s/dev" % mounts['root'])
+
+    try:
+        rc, out = util.runCmd2(['chroot', mounts['root'], 'rpm', '-q', 'kernel-alt', '--qf', '%{version}'],
+                               with_stdout=True)
+        version = out
+        # Generate the initrd as it was disabled during initial installation
+        util.runCmd2(['chroot', mounts['root'], 'dracut', '-f', '/boot/initrd-%s.img' % version, version])
+
+        # Update grub
+        util.runCmd2(['chroot', mounts['root'], 'python', '/usr/lib/python2.7/site-packages/xcp/updategrub.py', 'add', 'kernel-alt', version])
+    finally:
+        util.umount("%s/dev" % mounts['root'])
+        util.umount("%s/sys" % mounts['root'])
+        util.umount("%s/proc" % mounts['root'])

 ################################################################################
 # OTHER HELPERS
diff --git c/constants.py w/constants.py
index 7b41480..dd0534e 100644
--- c/constants.py
+++ w/constants.py
@@ -58,9 +58,9 @@ def error_string(error, logname, with_hd):
     ) = range(3)

     ERROR_STRINGS = {
-        ERROR_STRING_UNKNOWN_ERROR_WITH_HD: "An unrecoverable error has occurred.  The details of the error can be found in the log file, which has been written to /tmp/%s (and /root/%s on your hard disk if possible).\n\nPlease refer to your user guide or contact a Technical Support Representative for more details.",
-        ERROR_STRING_UNKNOWN_ERROR_WITHOUT_HD: "An unrecoverable error has occurred.  The details of the error can be found in the log file, which has been written to /tmp/%s.\n\nPlease refer to your user guide or contact a Technical Support Representative for more details.",
-        ERROR_STRING_KNOWN_ERROR: "An unrecoverable error has occurred.  The error was:\n\n%s\n\nPlease refer to your user guide, or contact a Technical Support Representative, for further details."
+        ERROR_STRING_UNKNOWN_ERROR_WITH_HD: "An unrecoverable error has occurred.  The details of the error can be found in the log file, which has been written to /tmp/%s (and /root/%s on your hard disk if possible).",
+        ERROR_STRING_UNKNOWN_ERROR_WITHOUT_HD: "An unrecoverable error has occurred.  The details of the error can be found in the log file, which has been written to /tmp/%s.",
+        ERROR_STRING_KNOWN_ERROR: "An unrecoverable error has occurred.  The error was:\n\n%s"
         }

     if error == "":
diff --git c/disktools.py w/disktools.py
index 749b592..af7ac40 100644
--- c/disktools.py
+++ w/disktools.py
@@ -490,7 +490,7 @@ def diskDevice(partitionDevice):

 def determineMidfix(device):
     DISK_PREFIX = '/dev/'
-    P_STYLE_DISKS = [ 'cciss', 'ida', 'rd', 'sg', 'i2o', 'amiraid', 'iseries', 'emd', 'carmel', 'mapper/', 'nvme', 'md' ]
+    P_STYLE_DISKS = [ 'cciss', 'ida', 'rd', 'sg', 'i2o', 'amiraid', 'iseries', 'emd', 'carmel', 'mapper/', 'nvme', 'md', 'mmcblk' ]
     PART_STYLE_DISKS = [ 'disk/by-id' ]

     for key in P_STYLE_DISKS:
diff --git c/diskutil.py w/diskutil.py
index 91c5395..faaab3a 100644
--- c/diskutil.py
+++ w/diskutil.py
@@ -113,6 +113,9 @@ for major in range(72, 80) + range(104, 112):
 for major in range(48, 56):
     disk_nodes += [ (major, x * 8) for x in range(32) ]

+# /dev/mmcblk: mmcblk has major 179, each device usually (per kernel) has 7 minors
+disk_nodes += [ (179, x * 8) for x in range(32) ]
+
 def getDiskList():
     # read the partition tables:
     parts = open("/proc/partitions")
@@ -153,6 +156,21 @@ def getDiskList():

     return disks

+def create_raid(configuration):
+    if configuration:
+        for raid_device, members in configuration.viewitems():
+            # allows for idempotence
+            if not os.path.exists(raid_device):
+                for dev in members:
+                    util.runCmd2(['sgdisk', '--zap-all', dev])
+                    util.runCmd2(['mdadm', '--zero-superblock', '--force', dev])
+                    # let it fail without catching
+                cmd = ['mdadm', '--create', raid_device, '--run', '--metadata=1.0', '--level=mirror',
+                       '--raid-devices=%s' % (len(members))] + members
+                rc, out, err = util.runCmd2(cmd, with_stdout=True, with_stderr=True)
+                if rc != 0:
+                    raise Exception('Error running: %s\n%s\n\n%s' % (' '.join(cmd), out, err))
+
 def getPartitionList():
     disks = getDiskList()
     rv  = []
diff --git c/doc/answerfile.txt w/doc/answerfile.txt
index 1e1d41d..eaec14f 100644
--- c/doc/answerfile.txt
+++ w/doc/answerfile.txt
@@ -34,6 +34,29 @@ Restore:
   ...
 </restore>

+
+Common Attributes
+-----------------
+
+  repo-gpgcheck="false"
+
+    Disable check of repodata signature (`repo_gpgcheck=0` in
+    `yum.conf`), for all yum repositories that are not Supplemental
+    Packs (none of which are checked). Don't use this for a network
+    install of a production server, and make sure to verify the
+    authenticity of your install media through other means.
+
+    Validity: any <installation> operation.
+
+  gpgcheck="false"
+
+    Disable check of rpm signature (`gpgcheck=0` in `yum.conf`), for
+    all yum repositories that are not Supplemental Packs (none of
+    which are checked). Don't use this for a production server.
+
+    Validity: any <installation> operation.
+
+
 Elements common to all answerfiles, both 'installation' and 'restore'
 ---------------------------------------------------------------------

@@ -100,6 +123,15 @@ Elements for 'installation' modes
     The location of the installation repository or a Supplemental
     Pack. There may be multiple 'source' elements.

+    Optional attributes for <source> only:
+
+      repo-gpgcheck=bool
+      gpgcheck=bool
+
+        Override the global yum gpgcheck setting, respectively for
+        repodata and RPMs, for this source only.  Only applies to
+        repositories that are not Supplemental Packs (none of which
+        are checked).

   <bootloader location="mbr|partition">grub2|extlinux[D]|grub[D]</bootloader>?

@@ -156,6 +188,16 @@ Format of 'source' and 'driver-source'
 (Re)Install Elements
 --------------------

+  <raid device=dev>
+    <disk>dev1</disk>
+    <disk>dev2</disk>
+  </raid>?
+
+    Specifies the target disks and md device for creating a
+    software RAID 1 array. The md device can then be used in
+    <primary-disk> below. (new in xcp-ng 7.5.0-2 and 7.6)
+
+
   <primary-disk>dev</primary-disk>

     Specifies the target disk for installation.
diff --git c/doc/parameters.txt w/doc/parameters.txt
index c0f7881..3f5f3ed 100644
--- c/doc/parameters.txt
+++ w/doc/parameters.txt
@@ -220,3 +220,13 @@ Installer
   --cc-preparations

     Prepare configuration for common criteria security.
+
+
+  --no-repo-gpgcheck
+
+    Disable check of repodata signature, for all yum repositories.
+
+
+  --no-gpgcheck
+
+    Disable check of rpm signature, for all yum repositories.
diff --git c/install.py w/install.py
index 825b569..cc7085c 100755
--- c/install.py
+++ w/install.py
@@ -128,6 +128,20 @@ def go(ui, args, answerfile_address, answerfile_script):
         elif opt == "--cc-preparations":
             constants.CC_PREPARATIONS = True
             results['network-backend'] = constants.NETWORK_BACKEND_BRIDGE
+        # XCP-ng addition: alternate kernel
+        elif opt == "--kernel-alt":
+            results['kernel-alt'] = True
+            logger.log("Using alternate kernel.")
+        # XCP-ng: netinstall
+        elif opt == "--netinstall":
+            results['netinstall'] = True
+            logger.log("This is a netinstall.")
+        elif opt == "--no-repo-gpgcheck":
+            results['repo-gpgcheck'] = False
+            logger.log("Yum gpg check of repository disabled on command-line")
+        elif opt == "--no-gpgcheck":
+            results['gpgcheck'] = False
+            logger.log("Yum gpg check of RPMs disabled on command-line")

     if boot_console and not serial_console:
         serial_console = boot_console
diff --git c/product.py w/product.py
index 9879430..413a368 100644
--- c/product.py
+++ w/product.py
@@ -384,6 +384,11 @@ class ExistingInstallation:
             pciback = next((x for x in kernel_args if x.startswith('xen-pciback.hide=')), None)
             if pciback:
                 results['host-config']['xen-pciback.hide'] = pciback
+
+            #   - sched-gran
+            sched_gran = next((x for x in xen_args if x.startswith('sched-gran=')), None)
+            if sched_gran:
+                results['host-config']['sched-gran'] = sched_gran
         except:
             pass
         self.unmount_boot()
diff --git c/repository.py w/repository.py
index b0fb971..1f5c68b 100644
--- c/repository.py
+++ w/repository.py
@@ -181,7 +181,7 @@ class YumRepository(Repository):
         installed_repos[str(self)] = self
         return installed_repos

-    def _installPackages(self, progress_callback, mounts):
+    def _installPackages(self, progress_callback, mounts, kernel_alt):
         assert self._targets is not None
         url = self._accessor.url()
         logger.log("URL: " + str(url))
@@ -203,13 +203,15 @@ baseurl=%s
                 yum_conf.write(repo_config)

         self.disableInitrdCreation(mounts['root'])
+        if kernel_alt:
+            self._targets.append('kernel-alt')
         installFromYum(self._targets, mounts, progress_callback, self._cachedir)
         self.enableInitrdCreation()

-    def installPackages(self, progress_callback, mounts):
+    def installPackages(self, progress_callback, mounts, kernel_alt=False):
         self._accessor.start()
         try:
-            self._installPackages(progress_callback, mounts)
+            self._installPackages(progress_callback, mounts, kernel_alt)
         finally:
             self._accessor.finish()

@@ -236,12 +238,14 @@ class MainYumRepository(YumRepositoryWithInfo):
     """Represents a Yum repository containing the main XenServer installation."""

     INFO_FILENAME = ".treeinfo"
-    _targets = ['@xenserver_base', '@xenserver_dom0']
+    _targets = ['xcp-ng-deps']

     def __init__(self, accessor):
         super(MainYumRepository, self).__init__(accessor)
         self._identifier = MAIN_REPOSITORY_NAME
         self.keyfiles = []
+        self._repo_gpg_check = True
+        self._gpg_check = True

         def get_name_version(config_parser, section, name_key, vesion_key):
             name, version = None, None
@@ -312,10 +316,10 @@ class MainYumRepository(YumRepositoryWithInfo):
                 outfh = open(key_path, "w")
                 outfh.write(infh.read())
                 return """
-gpgcheck=1
-repo_gpgcheck=1
+gpgcheck=%s
+repo_gpgcheck=%s
 gpgkey=file://%s
-""" % (key_path)
+""" % (int(self._gpg_check), int(self._repo_gpg_check), key_path)
             finally:
                 if infh:
                     infh.close()
@@ -351,6 +355,13 @@ gpgkey=file://%s
             branding['product-build'] = self._build_number
         return branding

+    def setRepoGpgCheck(self, value):
+        logger.log("%s: setRepoGpgCheck(%s)" % (self, value))
+        self._repo_gpg_check = value
+
+    def setGpgCheck(self, value):
+        logger.log("%s: setGpgCheck(%s)" % (self, value))
+        self._gpg_check = value

 class UpdateYumRepository(YumRepositoryWithInfo):
     """Represents a Yum repository containing packages and associated meta data for an update."""
diff --git c/restore.py w/restore.py
index 3f4248d..01637f6 100644
--- c/restore.py
+++ w/restore.py
@@ -135,7 +135,11 @@ def restoreFromBackup(backup, progress=lambda x: ()):
                     backend.setEfiBootEntry(mounts, disk, boot_partnum, constants.INSTALL_TYPE_RESTORE, branding)
                 else:
                     if location == constants.BOOT_LOCATION_MBR:
-                        backend.installGrub2(mounts, disk, False)
+                        if diskutil.is_raid(disk):
+                            for member in diskutil.getDeviceSlaves(disk):
+                                backend.installGrub2(mounts, member, False)
+                        else:
+                            backend.installGrub2(mounts, disk, False)
                     else:
                         backend.installGrub2(mounts, restore_partition, True)
             else:
diff --git c/tui/__init__.py w/tui/__init__.py
index 8497557..b0d709b 100644
--- c/tui/__init__.py
+++ w/tui/__init__.py
@@ -8,6 +8,7 @@ import traceback
 import constants
 import sys
 from xcp import logger
+import platform

 screen = None
 help_pad = [33, 17, 16]
@@ -28,7 +29,7 @@ To advance to the next screen navigate to the Ok button and press Enter or press
 def init_ui():
     global screen
     screen = SnackScreen()
-    screen.drawRootText(0, 0, "Welcome to %s - Version %s" % (PRODUCT_BRAND or PLATFORM_NAME, PRODUCT_VERSION_TEXT))
+    screen.drawRootText(0, 0, "Welcome to %s - Version %s (Kernel %s)" % (PRODUCT_BRAND or PLATFORM_NAME, PRODUCT_VERSION_TEXT, platform.release()))
     if PRODUCT_BRAND:
         if len(COPYRIGHT_YEARS) > 0:
             screen.drawRootText(0, 1, "Copyright (c) %s %s" % (COPYRIGHT_YEARS, COMPANY_NAME_LEGAL))
diff --git c/tui/installer/__init__.py w/tui/installer/__init__.py
index 7a8f588..c05a5cc 100644
--- c/tui/installer/__init__.py
+++ w/tui/installer/__init__.py
@@ -119,6 +119,7 @@ def runMainSequence(results, ram_warning, vt_warning, suppress_extra_cd_dialog):
         results['preserve-settings'] = False

     seq = [
+        Step(uis.kernel_warning),
         Step(uis.welcome_screen),
         Step(uis.eula_screen),
         Step(uis.hardware_warnings,
diff --git c/tui/installer/screens.py w/tui/installer/screens.py
index 74bb8cf..d6168ba 100644
--- c/tui/installer/screens.py
+++ w/tui/installer/screens.py
@@ -38,6 +38,28 @@ def selectDefault(key, entries):
             return text, k
     return None

+# kernel-alt warning
+def kernel_warning(answers):
+    if answers.get("kernel-alt"):
+        button = snackutil.ButtonChoiceWindowEx(
+            tui.screen,
+            "Alternate kernel",
+            """WARNING: you chose to install our alternative kernel (kernel-alt).
+
+It is based on our main kernel + upstream kernel.org patches, so it should be stable by construction. However it receives less testing than the main kernel.
+
+A boot menu entry for kernel-alt will be added, but we will still boot the main kernel by default.
+
+If kernel-alt works BETTER than the main kernel for you, TELL US so that we may fix the main kernel!
+""",
+            ['Ok', 'Reboot'], width=60)
+
+        if button == 'ok' or button is None:
+            return True
+        else:
+            return EXIT
+    return True
+
 # welcome screen:
 def welcome_screen(answers):
     driver_answers = {'driver-repos': []}
@@ -504,6 +526,56 @@ def setup_runtime_networking(answers):
     # Get the answers from the user
     return tui.network.requireNetworking(answers, defaults)

+def raid_array_ui(answers):
+    disk_entries = sorted_disk_list()
+    raid_disks = [de for de in disk_entries if diskutil.is_raid(de)]
+    raid_slaves = [slave for master in raid_disks for slave in diskutil.getDeviceSlaves(master)]
+    entries = []
+    for de in disk_entries:
+        if de not in raid_slaves and de not in raid_disks:
+            vendor, model, size = diskutil.getExtendedDiskInfo(de)
+            string_entry = "%s - %s [%s %s]" % (
+                diskutil.getHumanDiskName(de), diskutil.getHumanDiskSize(size), vendor, model)
+            entries.append((string_entry, de))
+    if len(entries) < 2:
+        return SKIP_SCREEN
+    text = TextboxReflowed(54, "Do you want to group disks in a software RAID 1 array?  \n\n" +
+                           "The array will be created immediately and erase all the target disks.")
+    buttons = ButtonBar(tui.screen, [('Create', 'create'), ('Back', 'back')])
+    scroll, _ = snackutil.scrollHeight(3, len(entries))
+    cbt = CheckboxTree(3, scroll)
+    for (c_text, c_item) in entries:
+        cbt.append(c_text, c_item, False)
+    gf = GridFormHelp(tui.screen, 'RAID Array', 'guestdisk:info', 1, 4)
+    gf.add(text, 0, 0, padding=(0, 0, 0, 1))
+    gf.add(cbt, 0, 1, padding=(0, 0, 0, 1))
+    gf.add(buttons, 0, 3, growx=1)
+    gf.addHotKey('F5')
+
+    tui.update_help_line([None, "<F5> disk info"])
+    loop = True
+    while loop:
+        rc = gf.run()
+        if rc == 'F5':
+            disk_more_info(cbt.getCurrent())
+        else:
+            loop = False
+    tui.screen.popWindow()
+    tui.screen.popHelpLine()
+
+    button = buttons.buttonPressed(rc)
+    if button == 'create':
+        selected = cbt.getSelection()
+        txt = 'The content of the disks %s will be deleted when you activate "Ok"' % (str(selected))
+        title = 'RAID array creation'
+        confirmation = snackutil.ButtonChoiceWindowEx(tui.screen, title, txt, ('Ok', 'Cancel'), 40, default=1)
+        if confirmation == 'ok':
+            answers['raid'] = {'/dev/md127': selected}
+            tui.progress.showMessageDialog("Please wait", "Creating raid array...")
+            diskutil.create_raid(answers['raid'])
+            tui.progress.clearModelessDialog()
+    return REPEAT_STEP
+
 def disk_more_info(context):
     if not context: return True

@@ -532,14 +604,18 @@ def disk_more_info(context):
     return True

 def sorted_disk_list():
-    return sorted(diskutil.getQualifiedDiskList(),
-                  lambda x, y: len(x) == len(y) and cmp(x,y) or (len(x)-len(y)))
+    return sorted(set(diskutil.getQualifiedDiskList()),
+                  lambda x, y: len(x) == len(y) and cmp(x, y) or (len(x) - len(y)))
+
+def filter_out_raid_member(diskEntries):
+    raid_disks = [de for de in diskEntries if diskutil.is_raid(de)]
+    raid_slaves = set(member for master in raid_disks for member in diskutil.getDeviceSlaves(master))
+    return [e for e in diskEntries if e not in raid_slaves]

 # select drive to use as the Dom0 disk:
 def select_primary_disk(answers):
     button = None
-    diskEntries = sorted_disk_list()
-
+    diskEntries = filter_out_raid_member(sorted_disk_list())
     entries = []
     target_is_sr = {}
     min_primary_disk_size = constants.min_primary_disk_size
@@ -588,7 +664,7 @@ def select_primary_disk(answers):

 You may need to change your system settings to boot from this disk.""" % (MY_PRODUCT_BRAND),
             entries,
-            ['Ok', 'Back'], 55, scroll, height, default, help='pridisk:info',
+            ['Ok', 'Software RAID', 'Back'], 55, scroll, height, default, help='pridisk:info',
             hotkeys={'F5': disk_more_info})

         tui.screen.popHelpLine()
@@ -615,7 +691,12 @@ You may need to change your system settings to boot from this disk.""" % (MY_PRO
             else:
                 answers["preserve-first-partition"] = 'false'

-    if button is None: return SKIP_SCREEN
+    # XCP-ng: we replaced `SKIP_SCREEN` by `RIGHT_FORWARDS` for RAID support to avoid a loop after raid creation
+    if button is None: return RIGHT_FORWARDS
+
+    # XCP-ng
+    if button == 'software raid':
+        return raid_array_ui(answers)

     return RIGHT_FORWARDS

@@ -640,7 +721,7 @@ def check_sr_space(answers):
     return EXIT

 def select_guest_disks(answers):
-    diskEntries = sorted_disk_list()
+    diskEntries = filter_out_raid_member(sorted_disk_list())

     # CA-38329: filter out device mapper nodes (except primary disk) as these won't exist
     # at XenServer boot and therefore cannot be added as physical volumes to Local SR.
@@ -675,16 +756,18 @@ def select_guest_disks(answers):
     cbt = CheckboxTree(3, scroll)
     for (c_text, c_item) in entries:
         cbt.append(c_text, c_item, c_item in currently_selected)
-    txt = "Enable thin provisioning"
-    if len(BRAND_VDI) > 0:
-        txt += " (Optimized storage for %s)" % BRAND_VDI
-    tb = Checkbox(txt, srtype == constants.SR_TYPE_EXT and 1 or 0)
+    rb_title = Textbox(15, 1, "Storage type")
+    rb = RadioBar(tui.screen, (("LVM: block based. May be faster. Thick provisioning.",
+                                constants.SR_TYPE_LVM, srtype == constants.SR_TYPE_LVM),
+                               ("EXT: file based. May be slower. Thin provisioning.",
+                                constants.SR_TYPE_EXT, srtype == constants.SR_TYPE_EXT)))

-    gf = GridFormHelp(tui.screen, 'Virtual Machine Storage', 'guestdisk:info', 1, 4)
+    gf = GridFormHelp(tui.screen, 'Virtual Machine Storage', 'guestdisk:info', 1, 5)
     gf.add(text, 0, 0, padding=(0, 0, 0, 1))
     gf.add(cbt, 0, 1, padding=(0, 0, 0, 1))
-    gf.add(tb, 0, 2, padding=(0, 0, 0, 1))
-    gf.add(buttons, 0, 3, growx=1)
+    gf.add(rb_title, 0, 2, padding=(0, 0, 0, 1))
+    gf.add(rb, 0, 3, padding=(0, 0, 0, 1))
+    gf.add(buttons, 0, 4, growx=1)
     gf.addHotKey('F5')

     tui.update_help_line([None, "<F5> more info"])
@@ -704,7 +787,7 @@ def select_guest_disks(answers):
     if button == 'back': return LEFT_BACKWARDS

     answers['guest-disks'] = cbt.getSelection()
-    answers['sr-type'] = tb.selected() and constants.SR_TYPE_EXT or constants.SR_TYPE_LVM
+    answers['sr-type'] = rb.getSelection()
     answers['sr-on-primary'] = answers['primary-disk'] in answers['guest-disks']

     # if the user select no disks for guest storage, check this is what
diff --git c/tui/repo.py w/tui/repo.py
index a46eda2..2a23d98 100644
--- c/tui/repo.py
+++ w/tui/repo.py
@@ -89,6 +89,9 @@ def select_repo_source(answers, title, text, require_base_repo=True):
     entries = [ ENTRY_LOCAL ]

     default = ENTRY_LOCAL
+    if answers.get('netinstall'):
+        entries = []
+        default = ENTRY_URL
     if len(answers['network-hardware'].keys()) > 0:
         entries += [ ENTRY_URL, ENTRY_NFS ]

@@ -136,6 +139,8 @@ def get_url_location(answers, require_base_repo):
             user_field.set(answers['source-address'].getUsername())
         if answers['source-address'].getPassword() is not None:
             passwd_field.set(answers['source-address'].getPassword())
+    else:
+        url_field.set('http://mirrors.xcp-ng.org/netinstall/8.3')

     done = False
     while not done:
