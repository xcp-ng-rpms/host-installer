From 51b026c2653bf67f21e174917144558023d411b6 Mon Sep 17 00:00:00 2001
From: Lin Liu <Lin.Liu01@cloud.com>
Date: Wed, 26 Mar 2025 09:15:23 +0000
Subject: [PATCH 02/10] CP-53716: Drop ordering and renaming network interface

Host-installer used to order and rename network interface,
This is complicated and involve different components to cooperate

Now host-installer will
- Delegate the interface naming to systemd
- Delegate the ordering interface to networkd

Regarding `--map_netdev` to allow user to assign network interface
to a specific slot, host-installer just format and passthrough the
assignment to networkd through
/etc/firstboot.d/data/initial_network_device_rules.conf

Signed-off-by: Lin Liu <Lin.Liu01@cloud.com>
---
 backend.py         |  20 +----
 doc/parameters.txt |  18 ++--
 init               |  13 +--
 netutil.py         | 211 +++++++++++++++++----------------------------
 4 files changed, 99 insertions(+), 163 deletions(-)

diff --git a/backend.py b/backend.py
index f4c6856..9d60716 100644
--- a/backend.py
+++ b/backend.py
@@ -1450,6 +1450,8 @@ def configureNetworking(mounts, admin_iface, admin_bridge, admin_config, hn_conf
 
 
     network_scripts_dir = os.path.join(mounts['root'], 'etc/sysconfig/network-scripts')
+    if not os.path.exists(network_scripts_dir):
+        os.makedirs(network_scripts_dir, exist_ok=True)
 
     # remove any files that may be present in the filesystem already,
     # particularly those created by kudzu:
@@ -1469,9 +1471,6 @@ def configureNetworking(mounts, admin_iface, admin_bridge, admin_config, hn_conf
     lo.write("NAME=loopback\n")
     lo.close()
 
-    save_dir = os.path.join(mounts['root'], constants.FIRSTBOOT_DATA_DIR, 'initial-ifcfg')
-    util.assertDir(save_dir)
-
     # now we need to write /etc/sysconfig/network
     nfd = open("%s/etc/sysconfig/network" % mounts["root"], "w")
     nfd.write("NETWORKING=yes\n")
@@ -1485,19 +1484,8 @@ def configureNetworking(mounts, admin_iface, admin_bridge, admin_config, hn_conf
     nfd.write('NTPSERVERARGS="iburst prefer"\n')
     nfd.close()
 
-    # EA-1069 - write static-rules.conf and dynamic-rules.conf
-    if not os.path.exists(os.path.join(mounts['root'], 'etc/sysconfig/network-scripts/interface-rename-data/.from_install/')):
-        os.makedirs(os.path.join(mounts['root'], 'etc/sysconfig/network-scripts/interface-rename-data/.from_install/'), 0o775)
-
-    netutil.static_rules.path = os.path.join(mounts['root'], 'etc/sysconfig/network-scripts/interface-rename-data/static-rules.conf')
-    netutil.static_rules.save()
-    netutil.static_rules.path = os.path.join(mounts['root'], 'etc/sysconfig/network-scripts/interface-rename-data/.from_install/static-rules.conf')
-    netutil.static_rules.save()
-
-    netutil.dynamic_rules.path = os.path.join(mounts['root'], 'etc/sysconfig/network-scripts/interface-rename-data/dynamic-rules.json')
-    netutil.dynamic_rules.save()
-    netutil.dynamic_rules.path = os.path.join(mounts['root'], 'etc/sysconfig/network-scripts/interface-rename-data/.from_install/dynamic-rules.json')
-    netutil.dynamic_rules.save()
+    netutil.save_inteface_rules(os.path.join(mounts['root'], constants.FIRSTBOOT_DATA_DIR,
+                                             "initial_network_device_rules.conf"))
 
 def writeXencommons(controlID, mounts):
     with open(os.path.join(mounts['root'], constants.XENCOMMONS_FILE), "r") as f:
diff --git a/doc/parameters.txt b/doc/parameters.txt
index 568c52d..32200b5 100644
--- a/doc/parameters.txt
+++ b/doc/parameters.txt
@@ -153,14 +153,18 @@ Installer
     three answerfile options above, "" otherwise.
 
 
-  --map_netdev=eth:d|s:mac|pci[[index]]|ppn
+  --map_netdev=[eth]X[:d|s]:mac|pci[[index]]|label
 
-    Map interface with the given MAC address, PCI address or PPN to the given
-    interface name.
-    Some NICs expose multiple interfaces for a single PCI address.  In these
-    cases the PPN is often not reliable.  An index to a PCI address can be
-    specified if required (NICs are sorted in MAC order).  An index of 0 is
-    implied when one is not provided.
+    Map interface with the given MAC address, PCI address or label to the given interface name.
+    Some NICs expose multiple interfaces for a single PCI address
+    An index to a PCI address can be specified if required (NICs are sorted in MAC order).
+
+    - eth: literal string "eth", has no meaning, just for backward compatibility
+    - X: number, starting from 0,  the expected order of this interface
+    - d|s: has no meaning, just for backward compatibility
+    - mac: valid Mac address
+    - pci: valid PCI address. An index of 0 is implied when one is not provided
+    - label: valid interface name, it needs to be quoted to distinguish from other kind and take priority than others
 
 
   --network_config=dhcp[:vlan=vlan]|static:ip=ip;netmask=netmask[;gateway=gw][;dns=dns1[,dns2]][;domain=domain][;vlan=vlan]
diff --git a/init b/init
index 54c03f0..5d2e941 100755
--- a/init
+++ b/init
@@ -64,9 +64,8 @@ def configureNetworking(ui, device, config):
     iface_to_start = []
     if device == 'all':
         iface_to_start.extend(list(netcfg.keys()))
-    elif device.startswith('eth'):
-        if device in nethw:
-            iface_to_start.append(device)
+    elif device in nethw:
+        iface_to_start.append(device)
     else:
         # MAC address
         matching_list = [x for x in nethw.values() if x.hwaddr == device]
@@ -192,12 +191,8 @@ def main(args):
         logger.log("Loading keymap %s" % kmap)
         util.runCmd2(["/bin/loadkeys", kmap])
 
-    # Always sanitise netdevs - it generates
-    # data for later in the install
-    # CA-60620 - dont try and run remap_netdevs in the codepath where we are
-    # running several concurrent instances.  It causes fun with competing
-    # /sbin/ip renames
-    netutil.remap_netdevs(netdev_map)
+    # Generate interface order rules, which will be saved later
+    netutil.generate_interface_rules(netdev_map)
 
     # Attaches iSCSI disks listed in iSCSI Boot Firmware Tables.  This may
     # reserve NICs and so should be called before netutil.scanConfiguration
diff --git a/netutil.py b/netutil.py
index d4df413..10fb18e 100644
--- a/netutil.py
+++ b/netutil.py
@@ -51,15 +51,13 @@ def getNetifList(include_vlan=False):
     allNetifs = os.listdir("/sys/class/net")
 
     def ethfilter(interface, include_vlan):
-        return interface.startswith("eth") and (interface.isalnum() or
+        return interface != "lo" and (interface.isalnum() or
                                     (include_vlan and "." in interface))
 
-    def rankValue(ethx):
-        iface, vlan = splitInterfaceVlan(ethx)
-        return (int(iface.strip('eth'))*10000 + (int(vlan) if vlan else -1))
-
     relevant = [x for x in allNetifs if ethfilter(x, include_vlan)]
-    relevant.sort(key=lambda ethx: rankValue(ethx))
+    # We just need to make sure vlan comes after its hosting interface
+    # for systemd interface configuration
+    relevant.sort()
     return relevant
 
 def writeNetInterfaceFiles(configuration):
@@ -256,22 +254,54 @@ class NetDevices:
 import xcp.logger as LOG
 from xcp.pci import VALID_SBDFI
 from xcp.net.mac import VALID_COLON_MAC
-from xcp.net.ip import ip_link_set_name
-from xcp.net.ifrename.logic import rename, VALID_ETH_NAME
-from xcp.net.ifrename.macpci import MACPCI
-from xcp.net.ifrename.static import StaticRules
-from xcp.net.ifrename.dynamic import DynamicRules
-from xcp.net.ifrename.util import niceformat
 
-static_rules = StaticRules()
-dynamic_rules = DynamicRules()
-
-RX_ETH = VALID_ETH_NAME
 RX_MAC = VALID_COLON_MAC
 RX_PCI = VALID_SBDFI
-RX_PPN = re.compile(r"^(?:em\d+|pci\d+p\d+)$")
 
-def parse_arg(arg):
+interface_rules = []
+
+class Rule:
+    #pylint: disable=too-few-public-methods
+    """ Class for a interface rule"""
+    def __init__(self, slot, method, interface):
+        self.slot = int(slot)
+        self.method = method
+        self.interface = interface
+
+    def __str__(self):
+        return f'{self.slot}:{self.method}="{self.interface}"'
+
+    def __eq__(self, other):
+        # One postion can have only one interface
+        return (self.slot == other.slot and self.method == other.method
+               and self.interface == other.interface)
+
+    def __lt__(self, other):
+        return self.slot < other.slot
+
+
+def parse_interface_slot(rule):
+    """
+    Parse target slot and interface from rule
+    return:
+        Success: (slot, interface)
+        Fail: (None, None)
+    """
+    sep = ":"
+    split = rule.split(sep, 1)
+    if len(split) != 2:
+        LOG.warning(f"Invalid device mapping {rule} - Ignoring")
+        return None, None
+    target, remaining = split
+    target = target.lstrip("eth")
+    if not target.isnumeric():
+        LOG.warning(f"{target} slot is NOT a number, Ignoring")
+        return None, None
+    if remaining.startswith("s:") or remaining.startswith("d:"):
+        remaining = remaining.split(sep, 1)[1]
+    return target, remaining
+
+def parse_rule(rule):
     """
     Takes list from the code which parses the installer commandline.
     Returns a tupe:
@@ -279,122 +309,41 @@ def parse_arg(arg):
     or None if the parse was not successful
     """
 
-    split = arg.split(":", 2)
-
-    if len(split) != 3:
-        LOG.warning("Invalid device mapping '%s' - Ignoring" % (arg,))
-        return
-
-    eth, sd, val = split
-
-    if RX_ETH.match(eth) is None:
-        LOG.warning("'%s' is not a valid device name - Ignoring" % (eth,))
-        return
-
-    if sd not in ['s', 'd']:
-        LOG.warning("'%s' is not valid to distinguish between static/dynamic rules" % (sd,))
-        return
-
-    if sd == 's':
-        formulae = static_rules.formulae
-    else:
-        formulae = dynamic_rules.formulae
-
-    if len(val) < 2:
-        LOG.warning("'%s' is not a valid mapping target - Ignoring" % (val,))
-        return
+    slot, val = parse_interface_slot(rule)
+    if slot is None:
+        return None
 
     if val[0] == '"' and val[-1] == '"':
-        formulae[eth] = ('label', val[1:-1])
-    elif RX_MAC.match(val) is not None:
-        formulae[eth] = ('mac', val.lower())
-    elif RX_PCI.match(val) is not None:
-        formulae[eth] = ('pci', val.lower())
-    elif RX_PPN.match(val) is not None:
-        formulae[eth] = ('ppn', val.lower())
-    else:
-        LOG.warning("'%s' is not a recognised mapping target - Ignoring" % (val,))
-
-
-def remap_netdevs(remap_list):
-
-    # # rename everything sideways to safe faffing with temp renanes
-    # for x in ( x for x in os.listdir("/sys/class/net/") if x[:3] == "eth" ):
-    #     util.runCmd2(['ip', 'link', 'set', x, 'name', 'side-'+x])
-
+        return Rule(slot, "label", val[1:-1])
+    if RX_MAC.match(val) is not None:
+        return Rule(slot, "mac", val.lower())
+    if RX_PCI.match(val) is not None:
+        return Rule(slot, "pci", val.lower())
+    LOG.warning(f"'{val}' is not a valid interface format label|mac|pci, Ignoring")
+    return None
+
+def generate_interface_rules(remap_list):
+    """
+    Generate interface rules basing on remap_list
+    """
+    interface_rules.clear()
     for cmd in remap_list:
-        parse_arg(cmd)
-
-    # Grab the current state from biosdevname
-    current_eths = all_devices_all_names()
-    current_state = []
-
-    for nic in current_eths:
-        eth = current_eths[nic]
-
-        if not ( "BIOS device" in eth and
-                 "Kernel name" in eth and
-                 "Assigned MAC" in eth and
-                 "Bus Info" in eth and
-                 "all_ethN" in eth["BIOS device"] and
-                 "physical" in eth["BIOS device"]
-                  ):
-            LOG.error("Interface information for '%s' from biosdevname is "
-                      "incomplete; Discarding."
-                      % (eth.get("Kernel name", "Unknown"),))
-
-        try:
-            current_state.append(
-                MACPCI(eth["Assigned MAC"],
-                       eth["Bus Info"],
-                       kname=eth["Kernel name"],
-                       order=int(eth["BIOS device"]["all_ethN"][3:]),
-                       ppn=eth["BIOS device"]["physical"],
-                       label=eth.get("SMBIOS Label", "")
-                       ))
-        except Exception as e:
-            LOG.error("Can't generate current state for interface '%s' - "
-                      "%s" % (eth, e))
-    current_state.sort()
-
-    LOG.debug("Current state = %s" % (niceformat(current_state),))
-
-    static_rules.generate(current_state)
-    dynamic_rules.generate(current_state)
-
-    static_eths = [ x.tname for x in static_rules.rules ]
-    last_boot = [ x for x in dynamic_rules.rules if x.tname not in static_eths ]
-
-    LOG.debug("StaticRules Formulae = %s" % (niceformat(static_rules.formulae),))
-    LOG.debug("StaticRules Rules = %s" % (niceformat(static_rules.rules),))
-    LOG.debug("DynamicRules Lastboot = %s" % (niceformat(last_boot),))
-
-    # Invoke the renaming logic
-    try:
-        transactions = rename(static_rules=static_rules.rules,
-                              cur_state=current_state,
-                              last_state=last_boot,
-                              old_state=[])
-    except Exception as e:
-        LOG.critical("Problem from rename logic: %s.  Giving up" % (e,))
-        return
-
-    # Apply transactions, or explicitly state that there are none
-    if len (transactions):
-        for src, dst in transactions:
-            ip_link_set_name(src, dst)
-    else:
-        LOG.info("No transactions.  No need to rename any nics")
-
-
-    # Regenerate dynamic configuration
-    def macpci_as_list(x):
-        return [str(x.mac), str(x.pci), x.tname]
-
-    new_lastboot = list(map(macpci_as_list, current_state))
-    dynamic_rules.lastboot = new_lastboot
-
-    LOG.info("All done ordering the network devices")
+        rule = parse_rule(cmd)
+        if rule is None:
+            continue
+        exists = [r for r in interface_rules if r.slot == rule.slot]
+        if exists:
+            LOG.warning(f"Position for {rule} already occupied by {exists}, Ignoring")
+            continue
+        interface_rules.append(rule)
+    interface_rules.sort()
+
+def save_inteface_rules(path):
+    """ save interface_rules to path"""
+    os.makedirs(os.path.dirname(path), exist_ok=True)
+    with open(path, 'w', encoding="utf-8") as file:
+        for rule in interface_rules:
+            file.write(f"{rule}\n")
 
 def disable_ipv6_module(root):
     # Disable IPv6 loading by default.
-- 
2.39.5

